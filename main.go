package main

import (
	"context"
	"database/sql"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
	"text/template"
	"time"

	_ "github.com/go-sql-driver/mysql"
	"gopkg.in/yaml.v3"
)

// Version is the application version
const Version = "2.0.0"

// defaultTemplate is used when no template is specified in config
const defaultTemplate = `// Code generated by mysql-struct-gen. DO NOT EDIT.
// Generated at: {{ .Timestamp.Format "2006-01-02 15:04:05" }}

package {{ .PackageName }}
{{- if .Imports }}

import (
{{- range .Imports }}
	"{{ . }}"
{{- end }}
)
{{- end }}

{{ range .Tables }}
// {{ .Name }} represents the {{ .Name }} table
type {{ .Name }} struct {
{{- range .Fields }}
	{{ .Name }} {{ .Type }} {{ .Tags }}
{{- end }}
}
{{ end }}`

// Config represents the application configuration
type Config struct {
	Database DatabaseConfig `yaml:"database"`
	Output   OutputConfig   `yaml:"output"`
	Options  OptionsConfig  `yaml:"options"`
}

type DatabaseConfig struct {
	Host     string   `yaml:"host"`
	Port     int      `yaml:"port"`
	User     string   `yaml:"user"`
	Password string   `yaml:"password"`
	Name     string   `yaml:"name"`
	Tables   []string `yaml:"tables"` // Optional: specific tables to generate
}

type OutputConfig struct {
	PackageName  string `yaml:"package_name"`
	FileName     string `yaml:"file_name"`
	Template     string `yaml:"template"`      // Optional: inline template
	TemplatePath string `yaml:"template_path"` // Optional: custom template file
}

type OptionsConfig struct {
	TagLabel           string            `yaml:"tag_label"`
	JSONTags           bool              `yaml:"json_tags"`
	UsePointers        bool              `yaml:"use_pointers"`    // Use pointers for nullable fields instead of sql.Null*
	UseZeroValues      bool              `yaml:"use_zero_values"` // Use plain types for nullable fields (NULL becomes zero value)
	AdditionalTags     map[string]string `yaml:"additional_tags"` // Additional struct tags (e.g., gorm, validate, form)
	CustomTypeMappings map[string]string `yaml:"custom_type_mappings"`
}

// ColumnSchema represents database column metadata
type ColumnSchema struct {
	TableName              string
	ColumnName             string
	IsNullable             string
	DataType               string
	CharacterMaximumLength sql.NullInt64
	NumericPrecision       sql.NullInt64
	NumericScale           sql.NullInt64
	ColumnType             string
	ColumnKey              string
}

// Field represents a Go struct field
type Field struct {
	Name       string
	Type       string
	Tags       string
	IsNullable bool
}

// Table represents a database table with its fields
type Table struct {
	Name         string
	OriginalName string // Store original DB table name for comparison
	Fields       []Field
}

// TemplateData contains all data for template rendering
type TemplateData struct {
	PackageName string
	Imports     []string
	Tables      []Table
	Timestamp   time.Time
}

// Generator handles the struct generation
type Generator struct {
	config   *Config
	template *template.Template
}

func NewGenerator(configPath string) (*Generator, error) {
	config, err := loadConfig(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load config: %w", err)
	}

	g := &Generator{config: config}

	// Load template (priority: inline > file path > default constant)
	var tmpl *template.Template

	if config.Output.Template != "" {
		// Use inline template from config
		tmpl, err = template.New("inline").Parse(config.Output.Template)
		if err != nil {
			return nil, fmt.Errorf("failed to parse inline template: %w", err)
		}
	} else if config.Output.TemplatePath != "" {
		// Use external template file
		tmpl, err = template.ParseFiles(config.Output.TemplatePath)
		if err != nil {
			return nil, fmt.Errorf("failed to parse template file: %w", err)
		}
	} else {
		// Use default template constant
		tmpl, err = template.New("default").Parse(defaultTemplate)
		if err != nil {
			return nil, fmt.Errorf("failed to parse default template: %w", err)
		}
	}

	g.template = tmpl
	return g, nil
}

func loadConfig(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var config Config
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, err
	}

	// Set defaults
	if config.Output.PackageName == "" {
		config.Output.PackageName = "models"
	}
	if config.Output.FileName == "" {
		config.Output.FileName = "db_structs.go"
	}
	if config.Options.TagLabel == "" {
		config.Options.TagLabel = "db"
	}
	if config.Database.Port == 0 {
		config.Database.Port = 3306
	}

	return &config, nil
}

func (g *Generator) Generate(ctx context.Context) error {
	// Connect to database
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/information_schema",
		g.config.Database.User,
		g.config.Database.Password,
		g.config.Database.Host,
		g.config.Database.Port,
	)

	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return fmt.Errorf("failed to connect to database: %w", err)
	}
	defer db.Close()

	// Test connection
	if err := db.PingContext(ctx); err != nil {
		return fmt.Errorf("failed to ping database: %w", err)
	}

	// Get schema
	schemas, err := g.getSchema(ctx, db)
	if err != nil {
		return fmt.Errorf("failed to get schema: %w", err)
	}

	// Convert to template data
	templateData := g.buildTemplateData(schemas)

	// Generate output
	if err := g.writeOutput(templateData); err != nil {
		return fmt.Errorf("failed to write output: %w", err)
	}

	return nil
}

func (g *Generator) getSchema(ctx context.Context, db *sql.DB) ([]ColumnSchema, error) {
	query := `SELECT TABLE_NAME, COLUMN_NAME, IS_NULLABLE, DATA_TYPE,
		CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION, NUMERIC_SCALE, 
		COLUMN_TYPE, COLUMN_KEY 
		FROM COLUMNS 
		WHERE TABLE_SCHEMA = ?`

	args := []interface{}{g.config.Database.Name}

	// Add table filter if specified
	if len(g.config.Database.Tables) > 0 {
		placeholders := make([]string, len(g.config.Database.Tables))
		for i := range g.config.Database.Tables {
			placeholders[i] = "?"
			args = append(args, g.config.Database.Tables[i])
		}
		query += " AND TABLE_NAME IN (" + strings.Join(placeholders, ",") + ")"
	}

	query += " ORDER BY TABLE_NAME, ORDINAL_POSITION"

	rows, err := db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var columns []ColumnSchema
	for rows.Next() {
		var cs ColumnSchema
		err := rows.Scan(
			&cs.TableName, &cs.ColumnName, &cs.IsNullable, &cs.DataType,
			&cs.CharacterMaximumLength, &cs.NumericPrecision, &cs.NumericScale,
			&cs.ColumnType, &cs.ColumnKey,
		)
		if err != nil {
			return nil, err
		}
		columns = append(columns, cs)
	}

	return columns, rows.Err()
}

func (g *Generator) buildTemplateData(schemas []ColumnSchema) *TemplateData {
	data := &TemplateData{
		PackageName: g.config.Output.PackageName,
		Timestamp:   time.Now(),
	}

	importsMap := make(map[string]bool)
	var tables []Table
	var currentTable *Table

	for _, schema := range schemas {
		// Start new table if needed (compare original table names)
		if currentTable == nil || currentTable.OriginalName != schema.TableName {
			if currentTable != nil {
				tables = append(tables, *currentTable)
			}
			currentTable = &Table{
				Name:         formatName(schema.TableName),
				OriginalName: schema.TableName,
				Fields:       []Field{},
			}
		}

		// Convert to Go type
		goType, requiredImport := g.goType(&schema)
		if requiredImport != "" {
			importsMap[requiredImport] = true
		}

		// Build tags
		tags := g.buildTags(&schema)

		field := Field{
			Name:       formatName(schema.ColumnName),
			Type:       goType,
			Tags:       tags,
			IsNullable: schema.IsNullable == "YES",
		}
		currentTable.Fields = append(currentTable.Fields, field)
	}

	// Add last table
	if currentTable != nil {
		tables = append(tables, *currentTable)
	}

	data.Tables = tables

	// Convert imports map to slice
	for imp := range importsMap {
		data.Imports = append(data.Imports, imp)
	}

	return data
}

func (g *Generator) buildTags(schema *ColumnSchema) string {
	var tags []string

	// Database tag
	if g.config.Options.TagLabel != "" {
		tags = append(tags, fmt.Sprintf(`%s:"%s"`, g.config.Options.TagLabel, schema.ColumnName))
	}

	// JSON tag
	if g.config.Options.JSONTags {
		jsonName := strings.ToLower(schema.ColumnName)
		omitEmpty := ""
		if schema.IsNullable == "YES" {
			omitEmpty = ",omitempty"
		}
		tags = append(tags, fmt.Sprintf(`json:"%s%s"`, jsonName, omitEmpty))
	}

	// Additional custom tags
	for tagName, tagPattern := range g.config.Options.AdditionalTags {
		tagValue := g.replacePlaceholders(tagPattern, schema)
		tags = append(tags, fmt.Sprintf(`%s:"%s"`, tagName, tagValue))
	}

	if len(tags) == 0 {
		return ""
	}

	return "`" + strings.Join(tags, " ") + "`"
}

func (g *Generator) replacePlaceholders(pattern string, schema *ColumnSchema) string {
	result := pattern

	// Replace common placeholders
	replacements := map[string]string{
		"{column}":      schema.ColumnName,
		"{field}":       formatName(schema.ColumnName),
		"{type}":        schema.DataType,
		"{column_type}": schema.ColumnType,
		"{table}":       schema.TableName,
	}

	for placeholder, value := range replacements {
		result = strings.ReplaceAll(result, placeholder, value)
	}

	return result
}

func (g *Generator) goType(col *ColumnSchema) (string, string) {
	// Check custom mappings first
	if customType, ok := g.config.Options.CustomTypeMappings[col.DataType]; ok {
		return customType, ""
	}

	requiredImport := ""
	isNullable := col.IsNullable == "YES"

	var goType string
	switch col.DataType {
	case "char", "varchar", "enum", "set", "text", "longtext", "mediumtext", "tinytext":
		if isNullable && !g.config.Options.UseZeroValues {
			if g.config.Options.UsePointers {
				goType = "*string"
			} else {
				goType = "sql.NullString"
				requiredImport = "database/sql"
			}
		} else {
			goType = "string"
		}

	case "blob", "mediumblob", "longblob", "varbinary", "binary":
		goType = "[]byte"

	case "date", "time", "datetime", "timestamp":
		if isNullable && !g.config.Options.UseZeroValues {
			if g.config.Options.UsePointers {
				goType = "*time.Time"
				requiredImport = "time"
			} else {
				goType = "sql.NullTime"
				requiredImport = "database/sql"
			}
		} else {
			goType = "time.Time"
			requiredImport = "time"
		}

	case "bit", "tinyint", "smallint", "int", "mediumint", "bigint":
		if isNullable && !g.config.Options.UseZeroValues {
			if g.config.Options.UsePointers {
				goType = "*int64"
			} else {
				goType = "sql.NullInt64"
				requiredImport = "database/sql"
			}
		} else {
			goType = "int64"
		}

	case "float", "decimal", "double":
		if isNullable && !g.config.Options.UseZeroValues {
			if g.config.Options.UsePointers {
				goType = "*float64"
			} else {
				goType = "sql.NullFloat64"
				requiredImport = "database/sql"
			}
		} else {
			goType = "float64"
		}

	default:
		goType = "interface{}"
	}

	return goType, requiredImport
}

func (g *Generator) writeOutput(data *TemplateData) error {
	file, err := os.Create(g.config.Output.FileName)
	if err != nil {
		return err
	}
	defer file.Close()

	return g.template.Execute(file, data)
}

func formatName(name string) string {
	parts := strings.Split(name, "_")
	var result strings.Builder
	for _, part := range parts {
		if len(part) > 0 {
			result.WriteString(strings.ToUpper(part[0:1]) + part[1:])
		}
	}
	return result.String()
}

func main() {
	// CLI flags
	configFile := flag.String("c", "", "Path to configuration file (shorthand)")
	configFileLong := flag.String("config", "config.yaml", "Path to configuration file")
	version := flag.Bool("version", false, "Show version information")
	versionShort := flag.Bool("v", false, "Show version information (shorthand)")

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "MySQL to Go Struct Generator\n\n")
		fmt.Fprintf(os.Stderr, "Usage:\n")
		fmt.Fprintf(os.Stderr, "  %s [options]\n\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "Options:\n")
		fmt.Fprintf(os.Stderr, "  -c, -config string\n")
		fmt.Fprintf(os.Stderr, "        Path to configuration file (default: config.yaml)\n")
		fmt.Fprintf(os.Stderr, "  -v, -version\n")
		fmt.Fprintf(os.Stderr, "        Show version information\n")
		fmt.Fprintf(os.Stderr, "\nExamples:\n")
		fmt.Fprintf(os.Stderr, "  %s -c myconfig.yaml\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "  %s -config production.yaml\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "  %s -version\n", os.Args[0])
	}

	flag.Parse()

	// Show version and exit
	if *version || *versionShort {
		fmt.Printf("mysql-struct-gen version %s\n", Version)
		fmt.Println("Modern MySQL to Go struct generator")
		os.Exit(0)
	}

	// Determine which config file to use (short flag takes precedence)
	configPath := *configFileLong
	if *configFile != "" {
		configPath = *configFile
	}

	// Check if config file exists
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		log.Fatalf("Configuration file not found: %s", configPath)
	}

	ctx := context.Background()

	generator, err := NewGenerator(configPath)
	if err != nil {
		log.Fatalf("Failed to create generator: %v", err)
	}

	fmt.Printf("Generating structs from database: %s\n", generator.config.Database.Name)

	if err := generator.Generate(ctx); err != nil {
		log.Fatalf("Failed to generate structs: %v", err)
	}

	fmt.Printf("âœ“ Successfully generated structs in %s\n", generator.config.Output.FileName)
}
